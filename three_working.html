<html>
<head>
	<title>My first Three.js app</title>
	<style>
	body { margin: 0; }
	canvas {
		background-color: #000;
		width: 200px;
		height: 200px;
		border: 1px solid black;
		margin: 100px;
		padding: 0px;
		position: static; /* fixed or static */
		top: 100px;
		left: 100px;
	}
	</style>


</head>
<body>
	<div id="canvas">
<!-- 
for(){
	for(){
	var binArray = pixells[].map(function(x){
		if (x.getVal()== true){
			return 1;

		}else{return 0;}


}       );
	return binArray;}
}
}
 -->








		<script src="js/three.min.js"></script>
		<script>

		var chevron =
		[
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
		[ 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
		[ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],		
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
		[ 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
		[ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],		
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
		[ 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
		[ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],		
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
		[ 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
		[ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],		
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
		[ 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0],
		[ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],
		[ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],



		];

		var checkerboard = 
		
		[
		[ 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
		[ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],
		[ 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
		[ 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],
		[ 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
		[ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],
		[ 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
		[ 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],
		[ 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
		[ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],
		[ 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
		[ 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],
		[ 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
		[ 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],
		[ 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
		[ 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],


		];

		var container = document.getElementById( 'canvas' );
		document.body.appendChild( container );



		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 1100 );
		camera.position.z = 1000;
		camera.position.y = 315;
		camera.position.x = 315;



		var renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setClearColor( 0xffffff, 1 ); 
	// renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setSize( 600, 600 );
	container.appendChild( renderer.domElement );

	//document.body.appendChild( renderer.domElement );

	var geometry = new THREE.BoxGeometry( 1, 1, 1 );
	var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
	var cube = new THREE.Mesh( geometry, material );
	scene.add( cube );

	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,0,700);
	scene.add(light);

	var darkMaterial = new THREE.MeshLambertMaterial( { color: 0x00ffcc } );
	var lightMaterial = new THREE.MeshLambertMaterial( { color: 0xffffcc } );

	var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } ); 
	var multiMaterial = [ darkMaterial, wireframeMaterial ]; 



	var curve = new THREE.CatmullRomCurve3( [
		new THREE.Vector3( 0, 0, 0 ),
		new THREE.Vector3( 600, 0, 0 ),
		new THREE.Vector3(600, 600, 0 ),
		new THREE.Vector3( 0, 600, 0 ),
		new THREE.Vector3( 0, 0, 0 ),





		] );

	var tapestryWarp =[];
	var tapestryWeft =[];


	function warpVerts(binArray, xIndex){ //takes an array of 0's and 1's for first parameter, and the index for second
	var thisArray=[];
	var crvID=0;


	for (var i = 0; i < binArray.length; i++){
		if (binArray[i]==0 && binArray[i-1] == 0){

			thisArray.push( new THREE.Vector3(xIndex*40,i*40,-10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+10,-10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+20,-10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+30,-10));

		}else if (binArray[i]==0 && binArray[i-1] == 1){

			thisArray.push( new THREE.Vector3(xIndex*40,i*40,0));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+10,0));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+20,-10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+30,-10));

		}else if (binArray[i]==1 && binArray[i-1] == 0){

			thisArray.push( new THREE.Vector3(xIndex*40,i*40,0));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+10,0));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+20,10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+30,10));

		}else if (binArray[i]==1 && binArray[i-1] == 1){

			thisArray.push( new THREE.Vector3(xIndex*40,i*40,10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+10,10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+20,10));
			thisArray.push( new THREE.Vector3(xIndex*40,i*40+30,10));

		};
	}


	tapestryWarp.push(new THREE.CatmullRomCurve3(thisArray));
}

function weftVerts(binArray, yIndex){ //takes an array of 0's and 1's for first parameter, and the index for second
var thisArray=[];
	//var crvID=0;


	for (var i = 0; i < binArray.length; i++){
		if (binArray[i]==0 && binArray[i-1] == 0){

			thisArray.push( new THREE.Vector3(i*40- 40, yIndex*40+40, 10));
			thisArray.push( new THREE.Vector3(i*40- 30,yIndex*40+40,10));
			thisArray.push( new THREE.Vector3(i*40- 20,yIndex*40+40,10));
			thisArray.push( new THREE.Vector3(i*40- 10,yIndex*40+40,10));

		}else if (binArray[i]==0 && binArray[i-1] == 1){

			thisArray.push( new THREE.Vector3(i*40 -40, yIndex*40+40, 0));
			thisArray.push( new THREE.Vector3(i*40- 30,yIndex*40+40,0));
			thisArray.push( new THREE.Vector3(i*40-20,yIndex*40+40,10));
			thisArray.push( new THREE.Vector3(i*40-10,yIndex*40+40,10));

		}else if (binArray[i]==1 && binArray[i-1] == 0){

			thisArray.push( new THREE.Vector3(i*40-40, yIndex*40+40, 0)) ;
			thisArray.push( new THREE.Vector3(i*40-30,yIndex*40+40,0));
			thisArray.push( new THREE.Vector3(i*40-20,yIndex*40+40,-10));
			thisArray.push( new THREE.Vector3(i*40-10,yIndex*40+40,-10));

		}else if (binArray[i]==1 && binArray[i-1] == 1){

			thisArray.push( new THREE.Vector3(i*40-40, yIndex*40+40,-10));
			thisArray.push( new THREE.Vector3(i*40-30,yIndex*40+40,-10));
			thisArray.push( new THREE.Vector3(i*40-20,yIndex*40+40,-10));
			thisArray.push( new THREE.Vector3(i*40-10,yIndex*40+40,-10));

		};
	}


	tapestryWeft.push(new THREE.CatmullRomCurve3(thisArray));
}








	var zipp; //

	function read2Darray(DArray){
		for (var i = 0; i < DArray.length; i++ ){
			weftVerts(DArray[i], i);
			//console.log(DArray);
		};


		var newArray = DArray[0].map(function(col, i) { 
			return DArray.map(function(row) { 
				return row[i] 
			})
		});

		for (var i = 0; i < newArray.length; i++ ){
			warpVerts(newArray[i], i);
		};



		for (var i = 0; i < tapestryWarp.length; i++ ){
		// 	if (tapestryWarp[i]){
		// 	//ar geo = new THREE.Mesh( new  THREE.TubeGeometry(tapestryWarp
		// [i], 20, 7, 8, false), darkMaterial);
			//geo.position.set(0, 0, -100);
			scene.add( new THREE.Mesh( new  THREE.TubeGeometry(tapestryWarp[i], 20, 15, 8, false), darkMaterial) );
			scene.add( new THREE.Mesh( new  THREE.TubeGeometry(tapestryWeft[i], 20, 15, 8, false), lightMaterial) );

		}
	}

	







	read2Darray(chevron);


//var warpArray = warpVerts([0,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0], 0);

	var geometry = new THREE.TubeGeometry(tapestryWarp[0],  //path
    20,    //segments
    7,     //radius
    8,     //radiusSegments
    false  //closed
    );


	var shape = new THREE.Mesh( 
		// total knot radius, tube radius, number cylinder segments, sides per cyl. segment,
		//  p-loops around torus, q-loops around torus
		geometry, 
		darkMaterial );
	//shape.position.set(0, 0, -100);
	scene.add( shape );
	
	

	

	//camera.position = new THREE.Vector3( 320, 320, 300 );


	var render = function () {
		requestAnimationFrame( render );

		cube.rotation.x += 0.1;
		cube.rotation.y += 0.1;

		renderer.render(scene, camera);
	};

	render();
	</script>















</body>
</html>